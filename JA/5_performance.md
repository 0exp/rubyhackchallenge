# (5) 性能向上

## この資料について

この資料では、MRI の性能向上に関するいくつかの考え方、Tips について紹介します。

## 性能向上とは

ソフトウェアの「性能向上」という言葉を聞くと、多くの場合「高速化」、つまりプログラムの実行時間の短縮を思い浮かべることが多いのではないでしょうか。
もちろん高速化は性能向上のもっとも重要なものの一つですが、ほかにも向上するべき性能指標があり、そのどれが重要であるかはアプリケーションの特徴、利用用途によります。

性能指標について、いくつかあげてみます。思いつくままに書いているので、きっとほかにもあると思います。

* 時間に関する指標
  * 実行時間（スループット）
  * リアルタイム性（レイテンシ）
  * 起動時間

* 計算資源に関する指標
  * メモリ消費量
    * 生きているオブジェクトの数
    * 実メモリ消費量、仮想メモリ空間の広さ（e.g. TLB ミス）
    * プロセス fork 時の Copy on Write の親和性
  * CPU の利用率（同じ実行時間なら、少ない利用率の方が良い）
  * CPU の活用可能性（多くのCPU資源を利用することで性能改善できるかどうか）
  * I/O のための fd 消費量
  * ディスク利用量（バイナリサイズ等）

いくつかの性能指標は互いに相関しているものもあれば、逆相関であるものもあります。

相関している例：

* メモリ消費量を減らすことでキャッシュミスが減り、スループットが向上する
* オブジェクト生成を減らすことで、スループットが向上する

逆相関の例：

* リアルタイム性を向上するためにリアルタイム GC を導入 → スループットは低下
* ある頻出する特定の値の場合のコードを生成することで高速化 → メモリやディスクをより消費

自分が求める性能向上がどのようなものであるか意識し、またほかの指標に対してどのような影響を与えるか、それが許容範囲であるかを意識することは重要です。
また、計算機環境はどんどん変化していくので、昔は有効だった性能改善手法も、今では逆効果、というものもあります。

例えば、大昔はメモリはとても重要な資源でしたが、利用可能なメモリはどんどん増えていきました。
しかし、クラウド上の計算機環境を利用することになり、時間課金になると、今度はメモリ資源は貴重なものとして認識されるようになりました。

今、何が課題であるかを適切に把握することが大事です。

## 性能向上の考え方

### まず測ろう

まず、よく言われていることですが、実装する前に、適切に計測することが必要です。

目的がスループットの改善の場合、プログラムの、どの箇所が遅いのかを見極めるのが大事です。
Ruby レベルで stackprof 等のツールを用いて適切に把握し、さらにその箇所を Linux の perf コマンドを用いて詳細に分析することで、MRI のどこを改良すれば良いかわかります。

（ちなみに、これらツールは「嘘」をつくことがあります。あくまで人間の作ったツールなので、100% 信じることはできません（だって、難しいし、デバッグしづらい分野ですから）。何か妙な結果かな、と思ったら、ツールを疑うことも必要になります。何か変な評価結果が出てきてしまった場合、疑い、解決するためには、それらのツールがどのように作られているかを知っておくことが大事です）

### アルゴリズムとデータ構造

CS の基礎ですが、性能改善に一番効果があるのは、アルゴリズムを変更することです。

例えば、n 番目のフィボナッチ数を求める、よくあるプログラムを高速化してください、というお題があったとします。定義通りに書くと、このような感じでしょうか。

```
def fib(n)
  if n < 2
    1
  else
    fib(n-2) + fib(n-1)
  end
end

n = Integer(ARGV.shift || 35)
puts "fib(#{n}) = #{fib(n)}"
```

全体的な高速化のために、JIT コンパイラ（Just-in-Time コンパイラ、実行時コンパイラ）を開発する、再帰呼び出しを軽量化するために、再帰メソッド呼び出しを、単なるジャンプへ変換する、といった工夫が考えられます。が、それらの工夫では、たかだか数倍から数百倍の高速化しか見込めません（それだけ速くなればいいだろ、という話もありますが）。

もちろん、フィボナッチ数を求めるプログラムは、より高速なアルゴリズムで書き下すことができます。

```
def fib n
  a, b = 1, 1
  n.times{
    a, b = b, a+b
  }
  a
end

n = Integer(ARGV.shift || 35)
puts "fib(#{n}) = #{fib(n)}"
```

計算量でいうと、O(k^n) だったものが O(n) になりました。n によっては、数百倍などでは効かず、もっとえげつない高速化が達成できます（ちなみに、フィボナッチ数を求めるプログラムは O(log n) で実現できることが知られています）。

というわけで、まずはアルゴリズムを根本的に変更できないか、検討することが大事です。

というのが、よくある性能向上に関する議論なのですが、もうちょっとだけ。

例えば計算量が改善するアルゴリズムがあったとき、与えられた n が十分に小さければ、実はほかの計算量が多いアルゴリズムの方が効率的、ということがあります（例えば、リニアサーチとバイナリサーチ）。
また、計算量が優れているアルゴリズムで実装するよりも、計算量について劣っているが、シンプルなアルゴリズムのほうが、すぐに実装できてバグが少ないプログラムになることがあります。
速いかもしれないけど、バグがある（かもしれない）プログラムは、そもそも使いたくないですよね。
また、実行に3秒かかるプログラム（開発に5分）と、それを改善して 0.3 秒で動くプログラム（開発に1時間）がある時、実は一度しか実行しないのであれば、圧倒的に前者を選択するべきです。

解くべき問題に応じて、執るべき手段を柔軟に選択していきましょう。

## MRI のいじりどころ

高速化のために、MRI でいじるべきところを見ていきます。

* 組み込みクラス・メソッド
  * （ほかのものも同じだが）アルゴリズムの改善を検討する。時々、面倒なので非効率（だけど簡単でバグが少ない）なアルゴリズムを使っていることがある。
  * 値の特殊化を検討する。よくあるケースを速くできないか検討する。例えば、`Array#[]` は、小さな整数値（インデックス）を引数に取ることが多い。
* 標準添付ライブラリ（`lib/`）
  * Ruby で書かれているため、不要なオブジェクト生成を抑制する、といった工夫が有効な場合がある。<https://github.com/ko1/allocation_tracer> こういうのを使うと便利。
* オブジェクト管理、ガーベージコレクタ
  * GC アルゴリズムを検討する。でも、まだやることあるかな？
  * オブジェクトのメモリレイアウトを検討する。
* VM
  * 命令セットを検討する。
  * JIT コンパイルを検討する。
  * 命令置き換え、インライン化等、コンパイラによる最適化を検討する。

ほかにも色々あると思われます。

（続く、かもしれない）
